  
  ## HTTP0.9
  * 只有一个命令（get）
  * 没有header等描述数据的信息， 只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客戶端的需求了，服务器也没有返回头信息，这是因为服务器端并不需要告诉客戶端太多信息，只需要返回数据就 可以了
  * 服务器发送完毕，就关闭TCP连接

  ## HTTP1.0
  * 增加三个方法，如post put、header
  * 增加了状态码，引入请求头和响应头
  * 支持多字符集、编码、压缩方式，多部分发送、权限、缓存等
    
  ## HTTP1.1(基于1.0增加一些功能, 最多建立6个头层皮、链接)
  * 支持持久连接keep-alive
  * 支持管线化pipeline（将多个请求打包一起发送到服务器上， 如： 请求1 -> 请求2 -> 请求3 -> 响应1->响应2->响应3， 按照顺序返回, 正常请求是： 请求1 -> 响应1 请求2 ->响应2 请求3->响应3), 管线化基于持久连接完成的
    注意： 1.只有get 和Head进行管线化，post有限制；
          2.初次连接不应启动管线化，因为服务器上不一定支持管线化
  * 增加Host和其他命令（即一台服务器上可部署多个服务，通过host进行判断）
  * 引入cookie\cache-control

  ## HTTP1.1存在的问题
  * tcp慢启动
  * 同时开启多个tcp连接，连接会竞争固定的带宽
  * http1.1队头阻塞问题,即虽然公用一个tcp管道，但管道中同一时刻只能处理一个请求,请求没有结束时，其他请求处于阻塞状态

  ## HTTP2
  * 所有的数据都是以二进制传输（之前版本多数以字符串发送）
  * 只需要一个tcp连接即可，采用管道复用，同一个连接里多个请求不在需要按照顺序来
  * 支持头部信息压缩以及推送(服务器端可主动发送请求)等高效率的功能
  * server push
  * 设置请求优先级

  ## HTTP2多路复用原理（管道复用）
  HTTP/2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP/2 的请求和接收过程。
  首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
  这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送 给服务器。
  服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
  然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
  同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
  浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。
  从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。
  
  ## HTTP2缺点
  * tcp慢启动
  * TCP对头阻塞
  
  QUIC 协议（全称 Quick UDP Internet Connections，快速 UDP 互联网连接）

  ## HTTPS

  [参考文章](https://www.chainnews.com/articles/401950499827.htm)