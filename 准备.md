 * js基础
 * js继承方式/apply/bind/new/promise/截流/防抖等操作实现
 * js创建对象的方式
 * react源码/react 全家桶
 * webpack配置相关
 * css布局(flex, grid)
 * css 动画 css3
 * css reflow/repaint
 * es6相关（promise、proxy、async、await、generator）
 * 阮一峰es6
 * 事件循环
 * 算法（基本算法/leetcode）
 * 设计模式
 * node 视频
 * 简历/项目经验
 * web安全、http网络相关
 * typescript/mobx
 * 自动化测试
 * JS垃圾回收机制
 * promise 装饰器 async await
 * css预处理器
 * webpack sourcemap 原理
 
## SSO(Single Sign-On)单点登录原理
 * sso是什么： SSO使得在多个应用系统中，用户只需要 登录一次 就可以访问所有相互信任的应用系统。
 * 原理： 

* 如何实现antd 中form表单

* 双向绑定原理

* react diff算法

* react fiber是什么，做了什么事

* react setState发生了什么

* babel中stage-0、stage-1/2/3都是什么
  1. Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel插件。
  2. Stage 1 - 建议（Proposal）：这是值得跟进的。
  3. Stage 2 - 草案（Draft）：初始规范。
  4. Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。
  5. Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。

* https为什么是安全的

* tls/ssl使用何种加密方式？ 对称加密、非对称加密和单向加密的区别？ 有哪些加密算法

* option预检请求如何实现缓存（嗅探请求，即只发送一次预检请求，之后就不发了）

* last-modified存在什么问题？

* etag如何计算出来的

* md5原理是什么

* promise/generator/async await区别及优缺点

* 如何实现一个require

* 事件循环，async await在哪个任务队列执行

* css性能，js阻塞渲染

* prefetch/preload的区别
  perload（不支持ie）： link标签的preload是一种声明式的资源获取请求方式，用于提前加载一些需要的依赖，并且不会影响页面的onload事件
  特点：1）preload加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞onload事件；
       2）peload可以支持加载多种类型的资源，并且可以加载跨域资源；
       3) preload加载的js脚本其加载和执行的过程是分离的。即preload会预加载相应的脚本代码，待到需要时自行调用；
  示例： <link rel="preload" as="font" href="www.font.com" crossorigin="anonymous">

  prefetch（支持ie11）: prefetch是一种利用浏览器的空闲时间加载页面将来可能用到的资源的一种机制；通常可以用于加载非首页的其他页面所需要的资源，以便加快后续页面的首屏速度；
  特点：prefetch加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少5分钟（无论资源是否可以缓存）；并且，当页面跳转时，未完成的prefetch请求不会被中断；

  对比：1）preload和prefetch都没有同域名的限制；
       2）preload主要用于预加载当前页面需要的资源；而prefetch主要用于加载将来页面可能需要的资源；
       3）不论资源是否可以缓存，prefecth会存储在net-stack cache中至少5分钟；
       4）preload需要使用as属性指定特定的资源类型以便浏览器为其分配一定的优先级，并能够正确加载资源；
  ```
    // 判断是否支持preload
    const preloadSupported = () => {
      const link = document.createElement('link');
      const relList = link.relList;
      if (!relList || relList.supports)
        return false;
      return relList.supports('preload');
    }
  ```
* 浏览器资源加载优先级(Highest 、 Medium 、 Low 、 Lowest 、 Idle)
  浏览器首先会按照资源默认的优先级确定加载顺序：
    html 、 css 、 font 这三种类型的资源优先级最高；
    然后是 preload 资源（通过 <link rel="preload"> 标签预加载）、 script 、 xhr 请求；
    接着是图片、语音、视频；
    最低的是prefetch预读取的资源。
* 资源优先级提升
  浏览器会按照如下规则，对优先级进行调整：

  对于XHR请求资源：将同步 XHR 请求的优先级调整为最高。
  对于图片资源：会根据图片是否在可见视图之内来改变优先级。图片资源的默认优先级为 Low 。现代浏览器为了提高用户首屏的体验，在渲染时会计算图片资源是否在首屏可见视图之内，在的话，会将这部分视口可见图片 ( Image in viewport ) 资源的优先级提升为 High 。
  对于脚本资源：浏览器会将根据脚本所处的位置和属性标签分为三类，分别设置优先级。
  首先，对于添加 defer / async 属性标签的脚本的优先级会全部降为 Low 。
  然后，对于没有添加该属性的脚本，根据该脚本在文档中的位置是在浏览器展示的第一张图片之前还是之后，又可分为两类。在之前的 ( 标记 early** ) 它会被定为High优先级，在之后的 ( 标记 late** ) 会被设置为 Medium 优先级。

* Chrome有四种缓存：http cache、memory cache、Service Worker cache和Push
* 编译型和解释型语言的区别
  编译型： 只须编译一次就可以把源代码编译成机器语言，后面的执行无须重新编译，直接使用之前的编译结果就可以；因此其执行的效率比较高；比如C、C++
  解释性：源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行，程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；如：JavaScript、Python

* null 与 undefined的区别
  Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。
  Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。

* indexof的实现

* 箭头函数this指向（内部和外部）

* setTimeout和setInterval区别
  setTimeout(fn,t),超时调用，超过时间t，就执行fn。
  setInterval(fn,t),间歇调用，调用周期t，执行fn。
  setInterval存在的问题：
      1.当setInterval中函数执行时间大于了延时时间， 当到了延时时间，即使函数没有执行完毕，也会再次将函数放到任务队列中,间隔时间不等于预设的间隔时间。
      2.当函数执行时间很长的时候，后续被添加到任务队列中函数会被忽略掉，因为务队列中不会有两个及以上同一个定时器的回调函数
  ```
  // 使用setTimeout替换setInterval，保证间隔时间相同
    var y=0;
    var z = new Date().getTime();
    var t = setTimeout(b,500);
    function b(){
      y++;
      sleep(2000)
      if(y>=10){
          clearTimeout(t)
      }else{
          setTimeout(arguments.callee,500);
      }
      console.log(new Date().getTime()-z);
    }
    function sleep(sleepTime){
        var start=new Date().getTime();
        while(true){
            if(new Date().getTime()-start>sleepTime){
                break;    
            }
        }
    }

  ```

 * ES6类与ES5类的区别
  ES6中方法不可枚举，而es5方法除构造函数之外，其他方法可枚举

 ### 单词缩写
  * DOM  document object model
  * xss
      跨域脚本攻击（cross-site scripting）
    
  * csrf
    ![csrf](./csrf.png)
    跨站请求伪造cross site request forgery
    产生必要两个步骤：1.在注册网站登录过、2.该网站某个接口存在这个漏洞

    csrf防御措施：
      1.token验证(登录过之后， 服务器下发token给客户端，每次请求时都手动携带token，cookie会自动携带，但token不会)
      2.refere验证
      3.隐藏令牌(放到http头中)

  * csrf与xss区别
    1.xss不需要用户登录注册，向页面中注入js，让js在执行，做想要做的事
    2.csrf：利用接口漏洞，需要用户登录
  
  * cors
  
  * 

### DOM 和 BOM

### 问题：
  * for in 与 for of区别
  * new Foo 和 new Foo（）
  * 闭包应用场景
  * Document对象属性、方法
  * Object对象属性方法
  * Object.create()以及Object.create方法实现
    Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
  * 301 与 302 304 403区别
  * 跨域解决方式/原理
  * 图片盗链问题
  * git常用命令， 对应场景
  * 正则表达式
  * JS模块化
  * 输入url到渲染出html的过程是怎样的
  * Object.assign方法浅拷贝， 深拷贝如何实现
  * es6中super的作用及示例
  * Promise是什么，解决什么问题， promise settimeout问题
  * 自定义iterator接口
  * url上的hash作用
  * axiso fetch 语法
  * Content-Type的值有哪些
  * 缓存（协商缓存、持久缓存）
  * 移动端适配
  * h5中input新增type有哪些
  * 图片3px缝隙问题
  * 定高/不定高垂直居中()
  * 浮动BFC问题
  * css单位有哪些
  * 替换元素和非替换元素：而根据是否具有可替换内容，我们也可以把元素分为替换元素和非替换元素。这种通过修改某个属性值，例如 <img> 的 "src" 属性，<input> 的 "type" 属性，呈现的内容就可以被改变的元素称为替换元素，例如：<img>,<input>,<textarea>,<select> 等等, 且元素一般拥有固定的尺寸（宽高或宽高比）
  * 移动端适配方案
  * js外链异步加载方式
  * 事件捕获、事件冒泡、事件委托
    事件委托: 利用事件冒泡的特性，将里层的事件委托给外层事件，根据event对象的属性进行事件委托，改善性能。
使用事件委托能够避免对特定的每个节点添加事件监听器；事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。
  * meta csrf-token
  * react和vue比较，优缺点，适用场景
  * 块级元素有哪些， 行内元素有哪些
  * 正则表达式
  * 
  