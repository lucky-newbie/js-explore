<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>模块化</title>
</head>
<script>

    /*
      知识点
        1.不使用模块化的情况
          a.代码间如果互相引用的话，需定义为全局变量，并且全局变量存在被污染场景
          b.代码间引用开发者清楚，维护者不清楚，之间依赖情况不清楚
        
        2.使用模块化的好处
          解决不使用模块化的问题

        3.AMD（异步模块定义）
          该规范示例：require.js
          全局define函数
          全局require函数
          依赖JS会自动、异步加载

          // b.js
          define(['./a.js'], function(){
            return {
              name: 'Tom'
            }
          })
          // main.js
          require([b.js], function(obj) {
            console.log(obj.name)
          })

        4.CommonJS
           nodejs 模块化规范，现被大量用前端， 原因：
           1.前端开发依赖的插件和枯，都可以从npm 中获取
           2.构建工具的高度自动化， 使得使用npm的成本非常低

          CommonJS不会异步加载JS， 是同步一次性加载出来的

          // 示例
          module.exports = {}
          const t = require('XXX')
    */

</script>
<script>
  /*
    AMD和CommonJS的使用场景
    1.需要异步加载JS，则使用AMD， 不需要异步，同步加载则用CommonJS
    2.使用了npm，则建议使用CommonJS
    
  */
</script>
<body>
  
</body>
</html>