
## 自我模拟面试问题记录

### css
 * css选择器有哪些？
  1. id选择器
  2. 类选择器/属性选择器/伪类选择器
  3. 标签选择器/伪元素选择器/组合选择器
  4. 通配符选择器
* css 选择器优先级
  1. ！important > 内联样式 > id选择器（100） > 类选择器/属性选择器/伪类选择器（10） > 标签选择器/组合选择器/伪元素选择器（1） > 通配符选择器
* 伪类有哪些？ 伪元素有哪些？ 区别是什么？
  1. 伪类选择器css2：
      :hover, :active, :link, :visited, :foucs, :blur
     伪类选择器CSS3:
      :nth-child,
      :nth-first-child,
      :nth-last-child,
      :nth-of-type(n)第几个同级别的兄弟元素,
      :empty
      :root
      :not 否定选择器，比如p:not(.p3){/*样式不为p3的p标签*/}
      :targe URL后面跟锚点#，指向文档内某个具体的元素。 也就是说，url后面的锚点，指向  某个元素， 那么该元素就会触发 target 
      :enabled
      :disabled
      :checked
  2. 伪元素： ::before, ::after, ::fisrt-line, ::first-letter
  3. 伪元素和伪类区别： 
    伪元素是用来创建原有dom结构树中不存在的元素，这些新创建的元素不会改变文档内容，不会出现在DOM树中，仅在css渲染层加入
    伪类表示已存在的某个元素处于的某种状态，总结来说即操作的对象元素是否存在于原来的DOM结构中

* 什么是BFC？， BFC触发条件有哪些？ BFC有何特点？ BFC应用场景/解决什么问题？
  1. blcok-formatting-context, 块级格式化上下文，它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。可以说BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。
  2. 触发条件： 
    float不为none；
    postion为absolute/fixed
    具有overflow属性并且不为visibke；
    display的值为：inline-block、table-cell、table-caption(表格标题)、
    弹性盒子flex
  3. 特点：
    内部的元素会在垂直方向一个接一个的排列；
    处于同一个BFC中的元素，在垂直方向可能会发生边距重叠;
    BFC会创建一个独立的区域，内部与外部互不影响
    BFC区域不育浮动重叠
    计算高度的时候，会计算BFC内部包含的所有元素，包括浮动元素
  4. 应用场景
    解决边距重叠；
    清除浮动，解决高度塌陷
* 浮动为何会产生高度塌陷？
  浮动会脱离当前文档流，那么它之前存在在父元素内的高度就随着浮动不复存在了，而此时父元素会默认自己里面没有任何内容（前提是未给父元素设置固定高度，如果父元素本身有固定高度，就不会出现这种情况）

* IFC问题参考css/盒模型.html

* 什么是盒模型？盒模型有哪些？如何设置？
  1. 盒模型包括：margin、border、padding、content
  2. 盒模型分为标准盒模型+IE盒模型, 标准盒模型宽度即为content的宽度， IE盒模型宽度为： border+padding+content
  3. 通过box-sizing: content-box(标准盒模型)、border-box(IE盒模型)
* 根据盒模型解释边距重叠
  兄弟节点之间有margin时，曲margin最大值（当块级元素设置为overflow时，会创建一个BFC）
* 获取元素宽度方式
  1. dom.style.width
  2. window.getComputedStyle(dom).width
  3. dom.getBoundingClientRect(); 得到坐标，基于right - left获取宽度
* 左侧固定，右侧自适应布局方案
  1. float + margin 优点：兼容性好； 缺点：需要清除浮动，解决高度塌陷
  2. 绝对定位  优点：兼容性好，缺点：绝对定位脱离了文档流，内部元素后续布局可能有问题
  3. inline-block方式:  优点：兼容性好， 缺点：文字间隙问题
  4. flex布局  优点：简单快捷； 缺点：IE10以上才支持
  5. grid布局 
* line-height:1.5 与 line-height： 150%的区别
  1. 父元素设置line-height:1.5会直接继承给子元素，子元素根据自己的font-size再去计算子元素自己的line-height。
  2. 父元素设置line-height:150%是计算好了line-height值，然后把这个计算值给子元素继承，子元素继承拿到的就是最终的值了。此时子元素设置font-size就对其line-height无影响了。

* css3有哪些新增属性
  box-shadow： 作用： 有立体感；创建无边框的的区域； 语法：box-shadow: 水平距离 垂直距离 模糊距离 扩展距离 颜色
  text-shadow: 作用：有立体感； 有印刷品质感  语法：text-shadow: 水平距离 垂直距离 模糊大小 颜色，如：text-shadow: 1px 1px 0 red;
  border-radius,
  linear-gradient: linear-gradient(45deg, red 0, green 10%, red 100%);
  radial-gradient: radial-gradient(closest-side at 60% 55%, red, yellow)
  clip-path,
  transition(transition-property/transition-duration/transition-timing-function/transition-delay)
  transition: transition: width 2s, background 1s
  transform(translate\scale\rotate（旋转）\skew斜切),
  animation(属性包括：animation-name\animation-duration、animation-play-state\animation-iteration-count\
  animation-timing-function\animation-fill-mode\animation-direction\animation-delay),
  fit-content
* 如何实现一个扇形
```
  .c4{
    width: 50px;
    height: 50px;
    background-color: red;
    border-top-left-radius: 50px;
  }
```
* 如何实现一个三角形
  .triangle{
    width: 0px;
    height: 0px;
    border: 5px solid red;
    border-color: transparent transparent red transparent;
  }
* css动画有几种？有什么区别？动画属性有哪些？
  1. 过渡动画 transition, transition-property, transition-duration, transition-timing-function, transition-delay
  2. 关键帧动画（补间动画）animation
  3. 区别：过度动画需要手动触发，关键帧不需要触发； 关键帧动画比过渡动画功能更强大，提供更多Api
  4. 动画原理： 视觉暂留作用 + 画面逐渐变化
  5. 动画作用：增强用户体验；引起用户注意；对用户信息进行反馈

* z-index与position的关系

* css 水平居中、垂直居中方案

* 块级元素有什么特点？有哪些？
  1. 不设置宽度默认为父元素宽度
  2. 独立占一行
  3. 可设置宽高margin pading
  4. header、section、div、article、footer、main、div、p

* 行内元素有什么特点？ 有哪些？
  1. 不可设置宽度、高度，宽度高度由内容撑开；
  2. 可设置水平方向的margin、padding，垂直方向设置无效
  3. 与其他元素排列到一行

* position的值有哪些？有什么区别？
  1. static: 默认值。即元素处于文档流给予的位置
  2. inherit: 从父元素继承position的,值 ie不支持
  3. relative：相对定位，相对于该元素在文档的初始位置进行定位，通过left、top、right、botto
m来设置该元素相对自身位置的偏移.
  4. fixed: 生成绝对定位，脱离文档流， 默认情况下相对于浏览器窗口进行定位偏移，但祖先元素具有
  transform属性且不为none的时候，相对祖先元素进行定位而不是浏览器.
  5. absolute: 绝对定位。相对于距该元素最近的已定位的元素进行定位， 脱离文档流
  6. sticky: 设置了position: sticky的元素并不脱离文档流，仍然保留元素原本在文档流中的位置
。当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动（相当于此时fixed定位）。

* css如何实现0.5px宽度？
```
  // 通过transform:scale实现
  <style>
  .line{
    position: relative;
  }
  .line::after{
    content: ' ';
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 1px;
    transform: scaleY(0.5);
    background: red;
  }
  </style>
  <div id='line'>
```
* flex布局属性有哪些？其中justify-content: space-around和space-between有何区别？
  1. 属性：
    flex-direction: column\row\row-reverse\column-reverse;
    flex-wrap: nowrap\wrap\wrap-reverse;
    flex-flow(flex-direction和flex-wrap简写方式)
    justify-content(定义了项目在主轴上的对齐方式): flex-start\flex-end\center\space-around\space-between
    align-items(定义项目在交叉轴上如何对齐): flex-start | flex-end | center | baseline | stretch(默认值，填充整个容器)
    align-content(属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用):  flex-start | flex-end | center | space-between | space-around | stretch;
  2.space-around和space-between区别：
    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
    space-between：两端对齐，项目之间的间隔都相等。

* grid布局及对应属性？flex布局与grid布局的区别
  1. 属性：
    grid-template-columns(定义列宽), repeat(次数，值)，如：grid-template-columns: repeat(3, 33.3%); // 设置三列，每列33.3%宽度
    grid-template-rows（定义行高）
    
  2. 区别：
    flex布局可以理解为一维布局；
    grid布局为二维布局;
  [阮一峰grid日志](http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)

* 浮动
  1. 浮动的特点：脱离文档流，但不脱离文本流，适合图文混排的场景
  2. 浮动对自身的影响： 创建了一个BFC区域，可以设置大小，位置尽量靠左（右），位置尽量靠上
  3. 对于兄弟节点的影响：上面贴非浮动元素，旁边贴浮动元素，不影响其他块元素位置，但影响快元素中文本内容
  4. 对父节点影响：从布局上‘消失’，出现高度塌陷问题


* css单位有哪些？区别是什么？

* rem原理， 如何实现？

* 移动端如何适配


* css性能优化方式有哪些
  1. 浏览器从右向左查找css，所以使用合适的选择器，减少查询次数；
  2. 使用css preload， 提前加载css
  3. 避免使用消耗性能的属性， 比如box-shadow border-radius transform 
  4. 避免重排
  5. 避免重绘
  6. 去除无用的css/压缩css内容/部分属性进行合并书写

## html
  * doctype的意义是什么？
    浏览器以标准模式渲染；让浏览器知道元素的合法性；
  * HTML元素分类有哪些？
    1. 按照样式分为块级元素、行内元素、内联块级元素inline-block
    2. 按照是否可替换 分为替换元素、非替换元素
    3. 按照内容类型划分： flow、heading、metadata、interactive等
  * 元素嵌套关系是怎样的？
    1. 块级元素可以包含行内元素
    2. 行内元素有时可以包含块级元素，比如<a><div></div></a>, 由于按照元素类型划分满足该场景
    3. 块级元素有时不能包含块级元素，比如p不能包含div

  * html5有什么新的变化？
    1. html语义话；
    2. form表单增强
    3. 新增api，比如canvas、web存储、audio、video等
    4. 分类和嵌套变更， 比如a标签嵌套div在之前html版本中不合法，但在html5中变成合法的

  * html5语义话是什么？有什么作用？
    1. 语义话： 用合理正确的标签去创建html结构，从而便于开发者阅读，维护和写出更优雅的代码的同时，让浏览器的爬虫和辅助技术更好的解析。
    2. 开发者容易理解
      机器容易理解解构（搜索、读屏幕软件）
      有助于SEO
      semantic microdata规范
  * input标签新增哪些类型？

  * html元素哪些可以自闭合
    input\br\meta\link\image
  * html和dom的关系
    dom由html解析得到
  * property 和 attribute有啥区别？
    property是dom的属性
    attribute是html标签的特性
  
## js
  * document方法有哪些？dom节点增删改查
  * DOM事件级别（DOM0， DOM2， DOM3）
    DOM0: element.onclick = function() {}
    DOM2: element.addEventListene('click', function(){,} false); 
          ie上写法: element.attachEvent('click', function(){})
    DOM3: 增加一些事件类型，比如鼠标、键盘事件，element.addEventListener('keyup', function(){})

  * DOM事件模型是什么？
    事件捕获/事件冒泡
  
  * DOM事件流是什么？
    从鼠标点击开始，选中对应元素
      1.捕获
      2.目标阶段
      3.冒泡 
  * 描述DOM事件捕获的具体流程：
    事件捕获：开始从window对象  -> document -> html(document.element获取html节点) -> body -> 按照层级进行传递 -> 目标元素
    事件冒泡： 事件捕获逆序
  
  * Event对象的常见应用有哪些？，如何注册事件
    1. event.preventDefault();  阻止默认事件
    2. event.stopPropagation(); 阻止冒泡，stopPropagation方法作用在后续节点上，目的在执行完绑定到当前元素上的所有事件处理程序之后，停止执行所有后续节点的事件处理程序
    3. event.stopImmediatePropagation() ：stopImmediatePropagation方法作用在当前节点以及事件链上的所有后续节点上，目的是在执行完当前事件处理程序之后，停止当前节点以及所有后续节点的事件处理程序的运行
    4. event.currentTarget 当前绑定事件的元素， 比如通过事件委托为多组img绑定点击事件，currentTarget即为div， target 为img
    5. event.target 当前点击的元素
    6. 注册事件：
    ```
    var eve = new Event('custome');
    window.addEventListener('custome', function() {
      console.log('触发')
    })
    window.dispatchEvent(eve)
    ```

  * 获取浏览器宽高

  * 原型链

  * 继承的方式

  * 闭包是什么？原理是什么？应用场景

  * 作用域链是什么?

  * this指向

  * 执行上下文
  
  * null和undifined的区别
    Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。
    Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。

  * 事件循环
    1. JS引擎线程只执行执行栈中的事件
    2. 执行栈中的代码执行完毕，就会读取事件队列中的事件
    3. 事件队列中的回调事件，是由各自线程插入到事件队列中的
    4. 如此循环
    如图所示：![事件循环](./eventloop.png)

  * bind实现

  * new实现
  ```
  function New() {
    const obj = {};
    const constructor = [].shift.call(arguments);
    obj.__proto__ = constructor.prototype;
    const res = constructor.apply(obj, arguments);
    return typeof res === 'object' ? res : obj;
  }
  ```

  * call、apply实现
  apply第二个参数为数组， call参数用逗号分割
  ```
  // apply实现
  Function.prototype.apply2 = function (context) {
    const c = context || window;
    c.fn = this;
    let res;
    // 判断是否有第二个参数
    if (arguments[1]) {
      res = c.fn(...arguments[1])
    } else {
      res = c.fn()
    }
    delete c.fn;
    return res;
  }

  // call实现
  Function.prototype.call2 = function (context) {
    context = context || window;
    context.fn = this;
    const args = [...arguments].slice(1); // 得到参数
    const res = context.fn(args);
    delete context.fn;
    return res;
  }
  ```

  * async/await实现

  * promise实现

  * 深拷贝实现
  1. JSON.parse(JSON.stringify(obj))
  2. 示例代码如下:
  ```
  function deepClone(obj) {
    // 此处仅判断是否是array
    const cloneObj = obj instanceof Array ? [] : {};
    for (key in obj) {
      if (typeof obj[key] === 'object') {
        cloneObj[key] = deepClone(obj[key])
      } else {
        cloneObj[key] = obj[key]
      }
    }
    return cloneObj;
  }
  ```

  * 防抖和截流

  * ajax实现
  ```
  // 不考虑兼容性问题
  const xhr = new XMLHttpRequest();
  xhr.open('get', 'url', true);
  xhr.onreadystatechange = function() {
    /*
      readyState状态码说明：
      0: 未初始化， 还没有调用send方法
      1: 载入， 已调用send方法，正在发送请求
      2: 载入完成， send方法执行完成，已经接收到全部响应内容
      3: 交互，正在解析响应内容
      4: 完成，响应内容解析完成，可以在客户端调用
    */
    // 判断readyState
    if (xhr.readyState == 4) {
      // 判断Http状态码
      if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206) {
        alert(xhr.responseText)
      }
    }
  }
  xhr.send()
  ```
  * 通过promise封装ajax
  ```
  // 不考虑兼容性，仅使用get请求
  const ajax = function(option) {
    const promise = new Promise((resolve, reject) => {
      let timer = null;
      let timeOut = option.timeout || 3000;
      const xhr = new XMLHttpRequest();
      let params = `${options.url}?`;
      for (key in option.data) {
        url += `&${key}=${option.data[key]}`
      }
      xhr.open('get', `${option.url}?${params.slice(1)}`, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200 || xhr.status === 304) {
            clearTimeout(timer)
            resolve(xhr.responseText)
          }
        }
        timer = setTimeout(function(){
          reject(xhr.status)
        }, timeOut)
      }
      xhr.send();
    })
    return promise;
  }
  ajax({
      method:"get",
      url:"./data.json",
      data:{
          id:10
      }
  }).then((res)=>{
        console.log(res)
  },(e)=>{
      console.log(e);
  })
  ```

  * Object.is实现原理

  * DOM事件流

  * 事件委托（事件代理）示例，有啥优点？
  1. 优点： 可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒；可以实现当新增子对象时无需再次对其绑定（动态绑定事件）
  ```
  
  ```

  * target\currentTarget\relateTarget区别
    1. target在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。
    2. event.currentTarget指向事件所绑定的元素，而event.target始终指向事件发生时的元素。
    3. 事件真正的发送者是event.target（而且是可以变的，根据触发的不同displayObject），注册侦听器的是event.currentTarget（不会变的）

  * mvc和mvvm的区别
  * 双向绑定是什么原理， 如何实现

  * js模块化

  * 工作中用到过哪些设计模式？

  * 文件上传



## react
  * react和vue的区别
  * react、vue、jquery在什么场景下使用
  * react生命周期
  * react性能优化方式
  * react setState同步异步问题
  * react16较react15做了什么改动
  * react hook是什么
  * react fiber是什么？为什么要这么做
  * react 虚拟dom原理
  * 如何实现antd 中form表单


## redux
redux-saga
redux-thunk

## react-router
* react-router升级做了什么

## webpack
  * webpack是什么？
  * loader和plugin有什么区别？ 如何写loader？ 如何写plugin
  * webpack实现原理
  * webpack sourcemap原理
  * webpack-dev-server 实现热更新原理

  * babel中stage-0、stage-1/2/3都是什么
    1. Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel插件。
    2. Stage 1 - 建议（Proposal）：这是值得跟进的。
    3. Stage 2 - 草案（Draft）：初始规范。
    4. Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。
    5. Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。

## 移动端
  * 不同设备如何解决1px问题


## http相关
  * 网络模型五层/七层
    物理层、数据链路层、网络层(IP,ICMP)、传输层(TCP, UDP)、（会话层(DNS协议)、表现层）应用层(HTTP、FTP, SMTP, NFS, WAIS)
  * 请求报文组成
    1. 首行：请求方法、请求url、http协议版本
    2. 请求头：
    3. 空行: 
    4. 请求体：
  * 响应报文组成
    1. 状态行：
    2. 响应头：
    3. 空行:
    4. 响应体:

  * http头部有哪些字段？
    
  * http有哪些特点？
    1. 无连接： 每次连接只处理一个请求，服务器处理完并收到客户的应答后，即断开连接
    2. 无状态：后续处理需要前面的信息，必须要重传
    3. 简单：客户端向服务器发送请求时，只需传方法和路径
    4. 灵活： 通过content-type进行标记，可以传输任意类型的数据

  * http发展史是怎样的，各版本改进了什么;
    1. http0.9
      * 为了传输html文件，只有一个get请求；
      * 仅有一个请求行，没有请求头请求体，响应也是一样；
      * 服务器发送完毕就关闭tcp链接；
    2. http1.0
      * 增加了三个方法：post、head，可以发送图片、二进制文件等;
      * 增加了状态码，引入了请求头响应头；
      * 支持多字符集、编码、压缩、缓存(expires\pragm)等
      * 缺点：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接
    3. http1.1（chrome为例，最多可以同时开启6个tcp链接）
      * 支持长链接keep-alive
      * 支持pipeline管线化（将多个请求打包一起发送到服务器，服务器按照顺序进行返回, 管线化基于长链接完成的， 注意：只有get和head支持管线化，post有限制，其次初次链接不应启动管线化，因为服务器不一定支持）
      * 增加host字段、cookie、cache-control
      * http1.1存在的问题：
        * tcp慢启动（由于三次握手）
        * 同时开启多个tcp连接，连接会竞争固定的带宽
        * http对头阻塞问题（由于tcp链接管道上同一时刻只能处理一个http请求）

    4. http2.0
      * 所有数据采用二进制传输（之前为字符串）
      * 只需要一个tcp链接即可，采用管道复用，同一个连接里面多个http请求不再按照顺序进行处理
      * 支持头部信息压缩及推送（server push）
      * 设置请求优先级
      http2存在问题： tcp慢启动、tcp队头阻塞
    5. http3.0

  * http2 管道复用原理？
    HTTP/2 添加了一个二进制分帧层,浏览器首先准备好请求数据，包括请求行、请求头、请求体，这些数据经过二进制分帧层处理之后，会被转换为一个个带有ID（奇数）编号的帧，通过协议栈将这些帧发送给服务器。服务器接收到之后，会将所有相同ID的帧合并为一个完整的请求信息，服务器处理该条请求，然后按照上述步骤（id为偶数）将响应信息进行拆分返还给浏览器

  * http状态码介绍
    * 1XX 指示信息-表示请求已接收，继续处理
    * 2XX 成功-表示请求已被成功接收
    * 3XX 重定向 - 要完成请求必须进行更进一步的操作
    * 4XX 客户端操作 - 请求有语法错误活请求无法实现
    * 5XX 服务器错误 - 服务器未能实现合法的请求
    状态码示例：
    200: ok 客户端请求成功
    206: 客户发送了一个带有Rang头的get请求，服务器完成了它，比如音频
    301: 永久重定向(示例： 原路径为‘/’， 后重定向到‘/a', 则301和302区别如下：
     1.请求时，服务器第一次会先到'/', 然后到‘/a’， 第二次则‘/a';
     2.状态码标记为301后，浏览器会将原来的'/'路径资源进行尽可能的长时间缓存，比如：第一次服务器返回302后，服务器将‘/’返回状态码标记为200，但浏览器在没清除缓存的情况下， 浏览器还是会返回‘/a’的内容.)
    302: 临时重定向(1.请求时服务器每次都会先到'/'， 然后在'/a'；)
    304：缓存，服务器告诉客户端可以从浏览器中读取缓存
    400: 客户端请求有语法错误，不能被服务器所理解
    401: 请求未授权
    403: 资源禁止被访问
    404: 请求资源不存在
    500: 
    502:
    503

  * http请求方法有哪些
    1. get： 获取数据
    2. post： 提交数据
    3. delete： 删除数据
    4. put： 更新数据
    5. head：与get请求类似，但head返回只有响应头，没有响应体，用来验证服务端性能
    6. option: 预检请求
    7. trace: 回馈服务器收到的请求，用于远程诊断服务器
    8. patch: 与put类似，patch一般用于部分资源的更新，put用于整体资源的更新

  * get请求和post请求区别
    1. get在浏览器回退是无害的，而post会再次提交请求 *
    2. get产生的url地址可以被收藏，而post不可以
    3. get请求会浏览器主动缓存，而post不会，除非手动设置 *
    4. get请求只能进行url编码，而post支持多种编码方式
    5. get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留 *
    6. get请求在url中传递参数的长度时有限制的（一般2kb，不同浏览器大小不同），而post没有限制 *
    7. 对参数的数据类型，get只接受ASCII字符，而post没有限制
    8. get比post更不安全，因为参数直接暴露在url上，不能传递敏感信息
    9. get参数通过url传递， 而post放到requestbody中 *

  * tcp三次握手
  * syn攻击

  * 同源策略限制内容有那些？什么是跨域？什么情况下会导致跨域？如何解决跨域？
    1. cookie、localstorage、DOM节点、ajax请求发送后会被浏览器拦截, 但link、img、script不会有跨域问题
    2. 浏览器同源策略限制，ip、端口、协议有一个不同就出现跨域问题, 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了
    3. 解决跨域方式：
      JSONP： 优点：简单兼容性好，缺点：只能发送get请求，不安全可能会收到xss攻击。jsonp属于非同源策略（跨域请求），ajax属于同源策略
      CORS方案: 需要服务端设置，比如
        access-control-allow-origin：ip地址；
        access-control-allow-headers：content-type；
        access-control-allow-methods： get、post
        access-aontrol-allow-credentials：true // 允许cookie
        分为简单请求和复杂请求：
        简单请求：1.请求方法为 get、post、head；2. content-type： text/plain、application/x-www-for-murlencoded、multipart/form-data; 3.请求头信息不超过以下几种字段：accept、accept-language、content-language、content-type
        复杂请求： 不满足以上场景的请求
      nginx反向代理方案
      node中间层，请求转发
      websocket
        ```
        const socket = new WebSocket('ws://localhost:3000');
        socket.onopen = function() {
          socket.send('发送给服务器信息')
        }
        socket.onmessage = function(e) {
          console.log(e.data)； // 服务器返回的数据
        }
        // 后段代码示例
        const express = require('express');
        const app = express();
        let WebSocket = require('ws');//记得安装ws
        let wss = new WebSocket.Server({port:3000});
        wss.on('connection',function(ws) {
          ws.on('message', function (data) {
            console.log(data);
            ws.send('服务器返回数据给前端')
          });
        })
        ```
      postmessage
      location.hash + iframe
      window.name + ifame

    * 缓存分类? 各类缓存应用场景?
      1. 强缓存
        expires(http1.0): Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。
        pragma(http1.0): HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存，Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和刷新(F5)类似。
        cache-control(http1.1): 
          private: 客户端可以缓存
          public： 客户端和代理服务器都可以缓存
          max-age=time: 缓存内容将会在time秒后失效
          no-cache：需要使用协商缓存来验证缓存数据
          no-store: 所有内容都不缓存
      2. 协商缓存 last-modified(if-Modified-Since)、etag(if-none-match)
      缓存应用场景：
        比如html可以使用协商缓存
        带有hash值的css、js、图片可以使用强缓存，hash值按照webpack划分可分为hash、content-hash、chunk-hash, 代码打包时使用content-hash

    * 301\302\304区别

    * https连接的建立过程，以及为什么https是安全的？

    * 加密算法有哪些？

    * etag如何生存
    * cdn原理是什么？
    * option预检请求如何只发送一次（嗅探请求）
      access-control-max-age： 600   即在十分钟内只有第一次有预见请求，后续没有了

## 性能优化
  * 首屏加载优化有哪些？
    1. DNS 预解析， 关键数据preload，非核心资源prefech
    2. webapck代码分割
    3. 公共依赖代码抽取，采用cdn方式加载
    4. 
    ....待补充....

  * 浏览器渲染过程
  * 重绘和重排是什么？ 如何避免/触发场景


## web安全问题
  * xss（corss site sript）,防护手段
    1. 反射型: 只是简单的把用户输入的数据反射给浏览器，这种攻击方式往往需要攻击者诱惑用户点击一个恶意
    链接，比如email、网站私信、评论等，服务器返回一个可执行脚本
    2. 存储型：会把用户输入的数据存储到服务器端，当浏览器请求数据时，脚本从服务器返回并执行
    。这种xss攻击具有很强的稳定性,比如在评论中输入一段js代码并提交，再次访问时浏览器执行该段代码
    3. 基于DOM: 指通过脚本修改页面DOM结构，存粹发生在客户端的攻击
    4.预防手段：httpOnly； 关键字进行转义; Cross Site Request Forgery（内容安全策略）

  * csrf(Cross Site Request Forgery), csrf防范


  * 点击劫持


## git

## 请求封装

## 组件封装



